<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prison Escape</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      background: #111;
      color: #0ff;
      font-family: 'Press Start 2P', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      user-select: none;
    }
    h1 {
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
      margin-bottom: 10px;
      font-size: 18px;
    }
    canvas {
      
      background: #222;
      box-shadow: 0 0 20px #0ffbb0;
      image-rendering: pixelated;
      display: block;
    }
    .hud {
      width: 480px;
      display: flex;
      justify-content: space-between;
      padding: 0 10px;
      margin-bottom: 8px;
      font-size: 12px;
      color: #0ff;
      text-shadow: 0 0 6px #0ffbb0;
    }
    .button {
      display: inline-block;
      margin-top: 1rem;
      padding: 1rem 2rem;
      color: #000;
      background: #0ff;
      border: 3px solid #f0f;
      box-shadow: 0 0 12px #0ff;
      text-decoration: none;
      font-size: 1rem;
      transition: 0.2s ease-in-out;
    }
    .button:hover {
      background: #f0f;
      color: #0ff;
      box-shadow: 0 0 16px #f0f;
    }

    .difficulty-buttons {
  display: flex;
  flex-direction: column;  
  position: absolute;
  right: 600px;             
  top: 50%;                
  transform: translateY(-50%);
  gap: 10px;               
}

.difficulty {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  border: 3px solid black;
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  color: black;
  background: white;
  cursor: pointer;
  box-shadow: 0 0 6px #000;
  transition: transform 0.2s;
}
.difficulty.baby { 
  background: white; 
  color: black; 
  border: 3px solid black; 
}

.difficulty.selected {
  box-shadow: 0 0 40px white; 
        
  border-width: 4px;          
}


.difficulty.easy { 
  background: green; 
  color: white; 
  border: 3px solid black; 
}

.difficulty.normal { 
  background: yellow; 
  color: black; 
  border: 3px solid black; 
}

.difficulty.hard { 
  background: red; 
  color: white; 
  border: 3px solid black; 
}

.difficulty.impossible { 
  background: black; 
  color: white; 
  border: 3px solid white; 
}


  </style>
</head>
<body>
  <h1>PRISON ESCAPE</h1>
  <div class="score">Maps Finished: 0</div>

  <div class="hud"></div>
  <canvas id="game" width="480" height="480"></canvas>
  <div class="difficulty-buttons">
  <button class="difficulty baby" onclick="setDifficulty(300)">Baby</button>
  <button class="difficulty easy" onclick="setDifficulty(200)">Easy</button>
  <button class="difficulty normal" onclick="setDifficulty(150)">Normal</button>
  <button class="difficulty hard" onclick="setDifficulty(87)">Difficult</button>
  <button class="difficulty impossible" onclick="setDifficulty(10)">Impossible</button>
</div>

  <a href="index.html" class="button">Back to Menu</a>


  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const tileSize = 30;
    const rows = 16;
    const cols = 16;
    const maps = 
     
  [
[
        "################",
        "#.#.#.#.#.#.#..#",
        "#.#.#.#.#.#.#.##",
        "#..............#",
        "##.#.#.#.#.#.#.#",
        "#..............#",
        "#.#.#.#.#.#.#.##",
        "#..............#",
        "##.#.#.#.#.#.#.#",
        "#..............#",
        "#.#.#.#.#.#.#.##",
        "#..............#",
        "##.#.#.#.#.#.#.#",
        "#..............#",
        ".....#.#.#.#.#.#",
        "################"
        ] , 
        [
        "################",
        "#.###.######...#",
        "#.#............#",
        "#.#.######.###.#",
        "#.#......#.#...#",
        "#.######.#.#.###",
        "#...#......#...#",
        "##.###.###.#####",
        "#......#.......#",
        "#.######.#######",
        "#..............#",
        "#####.########.#",
        "#..............#",
        "######.######.##",
        "...............#",
        "################"
      ],
      [
        "################",
        "#......#.......#",
        "#.##########.#.#",
        "#.#..........#.#",
        "#.#.######.#.#.#",
        "#.#.#....#.#.#.#",
        "#.#.#.##...#.#.#",
        "#.....##.#.#.#.#",
        "#.#.#....#.#.#.#",
        "#.#.######.#.#.#",
        "#.#........#.#.#",
        "#.##########.#.#",
        "#..............#",
        "#...####..#....#",
        "..........#....#",
        "################"
      ],
      [
        "################",
        "#......#.......#",
        "#.####.#.#####.#",
        "#.#....#.....#.#",
        "#.#.########.#.#",
        "#.#.#......#.#.#",
        "#.#.#.####.#.#.#",
        "#.#.#.#..#.#.#.#",
        "#.#.#.##.#.#.#.#",
        "#.#......#.....#",
        "#.############.#",
        "#....#...#.....#",
        "###..#.........#",
        "#........#.....#",
        ".........#.....#",
        "################"
      ],
        [
        "################",
        "#......#.......#",
        "#.####.#.#####.#",
        "#.#..........#.#",
        "#.#.##.#.###.#.#",
        "#.#.#..#.#.#.#.#",
        "#.#.####.#.#.#.#",
        "#.#......#.#.#.#",
        "#.########.#.#.#",
        "#..............#",
        "#.####.####.####",
        "#....#..#......#",
        "###..#..#......#",
        "#..........#####",
        ".....#.........#",
        "################"
      ],
      [
        "################",
        "#....#.........#",
        "#.####.####.####",
        "#.#....#.......#",
        "#.#....#.#####.#",
        "#.#.#..#.....#.#",
        "#.#.########.#.#",
        "#.#..........#.#",
        "#.#####.######.#",
        "#.....#.....#..#",
        "#...###.....#..#",
        "#........#..#..#",
        "##....####..#..#",
        "#...###........#",
        "...............#",
        "################"
      ],
   [
        "################",
        "#..............#",
        "#.####.#######.#",
        "#......#.......#",
        "#.#######.####.#",
        "#.........#....#",
        "#.###.##########",
        "#...#..........#",
        "#.####.#######.#",
        "#.......#......#",
        "#.###.########.#",
        "#.....#........#",
        "#.##.###.#####.#",
        "#..............#",
        "...............#",
        "#################"
      ],
  [
        "################",
        "#..#...........#",
        "#.##.#####.#####",
        "#....#.........#",
        "#.##########.###",
        "#......#.......#",
        "######.###..####",
        "#..............#",
        "#.#######.######",
        "#....#.........#",
        "####.#########.#",
        "#......#.......#",
        "#### # # #######",
        "#..............#",
        "......#...#....#",
        "################"
      ],
      [
        "################",
        "#.#............#",
        "#.#.######.#.#.#",
        "#.#......#.#.#.#",
        "#.######.#.#.#.#",
        "#........#.#.#.#",
        "#.####.#####.###",
        "#..............#",
        "#.######.####,##",
        "#.######.#.....#",
        "#..............#",
        "#.######.#####.#",
        "#..........#...#",
        "#######....#...#",
        "...............#",
        "################"
      ], 
              [
        "################",
        "#.....#........#",
        "#.##..##.###.###",
        "#.#..#.........#",
        "#.##.#.##..#.###",
        "#..............#",
        "#.###..#..##...#",
        "#...#...#.##...#",
        "###.....#..#...#",
        "#...#...#......#",
        "###.##...##.####",
        "#.....###...#..#",
        "#.#.###........#",
        "#.#.....#..#####",
        "......#........#",
        "################"
      ],
 

 
     
    ];

let currentMapIndex = 0;
let mapsFinished = 0;
let maze, player, cop, exit, gameOver, won, copInterval;

let copSpeed = 150; 
let selectedDifficulty = 'normal';

function loadProgress() {
  const savedIndex = localStorage.getItem('currentMapIndex');
  const savedFinished = localStorage.getItem('mapsFinished');
  if (savedIndex !== null) currentMapIndex = parseInt(savedIndex);
  if (savedFinished !== null) mapsFinished = parseInt(savedFinished);
  updateScore();
}

function saveProgress() {
  localStorage.setItem('currentMapIndex', currentMapIndex);
  localStorage.setItem('mapsFinished', mapsFinished);
}

function updateScore() {
  document.querySelector('.score').textContent = `Maps Finished: ${mapsFinished}`;
}

function startMap(index) {
  maze = maps[index];
  player = { x: 14, y: 1 };
  cop = { x: 1, y: 1 };
  exit = { x: 1, y: 14 };
  gameOver = false;
  won = false;
  drawMaze();
  if (copInterval) clearInterval(copInterval);
  copInterval = setInterval(moveCop, 250);
}

function nextMap() {
  if (currentMapIndex < maps.length - 1) {
    currentMapIndex++;
    startMap(currentMapIndex);
    saveProgress();
  }
}

function randomizeMap() {
  startMap(currentMapIndex); 
}


    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (maze[y][x] === "#") {
            ctx.fillStyle = "#0ff";
            ctx.shadowColor = "#0ff";
            ctx.shadowBlur = 6;
            ctx.fillRect(x * tileSize, y * tileSize, tileSize - 2, tileSize - 2);
            ctx.shadowBlur = 0;
          }
        }
      }
      drawDot(exit.x, exit.y, "#0f0"); 
      drawDot(cop.x, cop.y, "#f00");   
      drawDot(player.x, player.y, "#00f"); 
    }

    function drawDot(x, y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, tileSize / 3, 0, Math.PI * 2);
      ctx.fill();
    }

    function movePlayer(dx, dy) {
      if (gameOver) return;
      const nx = player.x + dx;
      const ny = player.y + dy;
      if (maze[ny][nx] !== "#") {
        player.x = nx;
        player.y = ny;
      }
      checkGameState();
      drawMaze();
    }

    function moveCop() {
      if (gameOver) return;

      const path = bfs(cop, player);
      if (path.length > 1) {
        cop.x = path[1].x;
        cop.y = path[1].y;
      }

      checkGameState();
      drawMaze();
    }

    function bfs(start, goal) {
      const queue = [{ x: start.x, y: start.y, path: [] }];
      const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
      visited[start.y][start.x] = true;

      const directions = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 }
      ];

      while (queue.length > 0) {
        const current = queue.shift();
        const { x, y, path } = current;

        if (x === goal.x && y === goal.y) {
          return [...path, { x, y }];
        }

        for (const dir of directions) {
          const nx = x + dir.x;
          const ny = y + dir.y;

          if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited[ny][nx] && maze[ny][nx] !== "#") {
            visited[ny][nx] = true;
            queue.push({ x: nx, y: ny, path: [...path, { x, y }] });
          }
        }
      }

      return []; 
    }

function checkGameState() {
  if (player.x === cop.x && player.y === cop.y) {
    gameOver = true;
    won = false;
    clearInterval(copInterval);
  } else if (player.x === exit.x && player.y === exit.y) {
    gameOver = true;
    won = true;
    clearInterval(copInterval);
    mapsFinished++;
    updateScore();
    saveProgress();

    if (currentMapIndex < maps.length - 1) {
      setTimeout(nextMap, 1000); 
    } else {
      
      gameOver = true;
      won = 'finished'; 
      clearInterval(copInterval);
    }
  }
}



function drawGameOver() {
  if (!gameOver) return;
  ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
  ctx.fillRect(0, canvas.height / 2 - 40, canvas.width, 80);

  ctx.font = "16px 'Press Start 2P'";
  ctx.textAlign = "center";

  if (won === 'finished') {
    ctx.fillStyle = "#0f0";
    ctx.shadowColor = "#0f0";
    ctx.shadowBlur = 20;
    ctx.fillText("YOU FINISHED!!", canvas.width / 2, canvas.height / 2 - 10);
  } else {
    ctx.fillStyle = won ? "#0f0" : "#f00";
    ctx.shadowColor = won ? "#0f0" : "#f00";
    ctx.shadowBlur = 20;
    ctx.fillText(won ? "YOU ESCAPED!" : "CAUGHT!", canvas.width / 2, canvas.height / 2 - 10);
  }

  ctx.shadowBlur = 0;
  ctx.font = "10px 'Press Start 2P'";
  ctx.fillStyle = "#0ff";
  ctx.shadowColor = "#0ff";
  ctx.shadowBlur = 10;
  ctx.fillText("Press SPACE to Restart", canvas.width / 2, canvas.height / 2 + 20);
}


document.addEventListener("keydown", (e) => {
  if (gameOver && e.code === "Space") {
    if (won === 'finished') {
      
      localStorage.removeItem('currentMapIndex');
      localStorage.removeItem('mapsFinished');
      currentMapIndex = 0;
      mapsFinished = 0;
      updateScore();
      startMap(currentMapIndex);
    } else {
      
      startMap(currentMapIndex);
    }
  }

  if (!gameOver) {
    if (e.key === "ArrowUp") movePlayer(0, -1);
    if (e.key === "ArrowDown") movePlayer(0, 1);
    if (e.key === "ArrowLeft") movePlayer(-1, 0);
    if (e.key === "ArrowRight") movePlayer(1, 0);
  }
});


function setDifficulty(speed) {
  copSpeed = speed;
  if (copInterval) {
    clearInterval(copInterval);
    copInterval = setInterval(moveCop, copSpeed);
  }


  document.querySelectorAll('.difficulty').forEach(btn => btn.classList.remove('selected'));

  
  const btn = Array.from(document.querySelectorAll('.difficulty'))
                   .find(b => {
                     return b.textContent === getDifficultyName(speed);
                   });
  if (btn) btn.classList.add('selected');
}


function getDifficultyName(speed) {
  switch(speed) {
    case 300: return "Baby";
    case 200: return "Easy";
    case 150: return "Normal";
    case 87:  return "Difficult";
    case 10:  return "Impossible";
  }
}




    function gameLoop() {
      drawMaze();
      drawGameOver();
      requestAnimationFrame(gameLoop);
    }

   loadProgress();
startMap(currentMapIndex);

document.querySelectorAll('.difficulty').forEach(btn => btn.classList.remove('selected'));
document.querySelector('.difficulty.normal').classList.add('selected');


gameLoop();

  </script>
</body>
</html>
